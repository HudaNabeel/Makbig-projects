// HOW js code executed?
// 1. Whenever any JavaScript code is executed an execution context is created and it is the Global Execution Context.
// 2. An Execution Context is basically a box which has two components called Memory Component(Variable Environment) and Code Component(Thread Of Execution).
// 3. The Execution context is created in two phases
//    a. Memory Creation Phase : In this Phase, Memory is allocated to all the variables and functions which are present in the           global scope. Special keyword Undefined in case of variables and literally the whole function in case of functions.
//    b. Code Execution Phase : In this Phase, code is executed line by line.

// const { find } = require("lodash");

// const { first } = require("lodash");

// 4. Whenever there is a function invocation an all new execution context is created and same process is followed again.
// 5. If there is any function parameter then it is also allocated memory while creating the execution context of the function.
// 6. Whenever return keyword is encountered , it means the task of function is over and it returns back the control of the program back to the place where it was invoked. and with this this execution context is deleted from stack.

// 7. Call Stack is basically a stack which maintains the order of execution of execution context. Whenever a code is executed the Global Execution Context is pushed into the stack first and later on as per the function invocation the  execution context is pushed into the stack. When the function code is done executing the execution context is popped out and last the Global Execution Context s also deleted
// 
// What is Hoisting?
// 1. Hoisting is a default behavior of JavaScript in which all the variable and function declarations are moved to the top of their scope before code execution.
// 2. Hoisting in JavaScript is a process in which all the Variables, Functions and Class defination are declared BEFORE execution of the code
// 3. Variables are initialised to UNDEFINED when they are declared and Function defination is stored AS IT IS.
// 4. They are declared in Memory Allocation Phase in the Memory Component of Execution Context, so we can use them even BEFORE they are declared.
// 5. UNDEFINED means Variable has been declared but value is not ASSIGNED but NOT DEFINED means Variables is NOT DECLARED.
// 6. When we assign Variable to a Function defination, we CAN NOT call this Variable as Function BEFORE declaration as it will behave as Variable with UNDEFINED value.

// AST (Abstract Syntax Tree):

// 1. AST is a tree representation of the structure of source code.
// 2. It is used by compilers and interpreters to analyze and understand the code.
// 3. The AST is generated by parsing the source code, breaking it down into its constituent parts, and organizing those parts into a hierarchical structure.
// 4. Each node in the tree represents a construct in the source code, such as a variable declaration, function call, or control flow statement.
// 5. The AST can be used for various purposes, such as code optimization, code generation, and static analysis.
// 6. By analyzing the AST, developers can gain insights into the structure and behavior of their code, identify potential issues, and make improvements to the codebase.

// memory allocation (heap and stack)
// 1. Memory allocation in JavaScript is divided into two main areas: the stack and the heap.
// 2. The stack is used for static memory allocation, where the size of the data is known at compile time.
// 3. The heap is used for dynamic memory allocation, where the size of the data can change at runtime.
// 4. Primitive data types (e.g., numbers, strings, booleans) are stored on the stack.
// 5. Objects and arrays are stored on the heap, and a reference to the memory location is stored on the stack.
// 6. When a function is called, a new stack frame is created to hold the function's local variables and parameters.
// 7. When the function returns, the stack frame is removed, and the memory is freed up.
// 8. The heap is managed by a garbage collector, which automatically frees up memory that is no longer being used by the program.


// working in the js  playground
// 1. Open a web browser and navigate to a JavaScript playground website, such as JSFiddle, CodePen, or Repl.it.
// 2. Create a new project or fiddle.
// 3. Write your JavaScript code in the provided editor.
// 4. Use the built-in tools to test and debug your code.
// 5. Share your code with others by providing a link to your project or fiddle.
// 6. Experiment with different libraries and frameworks to enhance your JavaScript skills.
// 7. Save your work frequently to avoid losing any changes.
// 8. Explore the community features of the playground to learn from other developers and get feedback on your code.

// callback function
// A callback function is a function that is passed as an argument to another function and is executed after a certain event or condition is met.


// hoisting

// display();
// console.log(x);


// var x = 8;
// const  display = () => {
//     console.log("Hello JavaScript");
// }

//  function work 
// var x = 1;

// a();
// b();

// function a() {
//     var x = 10;
//     console.log(x);
// }


// function b() {
//     var x = 100;
//     console.log(x);
// }

// console.log(x);

// call back function


//   setTimeout(function(){
//  console.log("timer")
//   }, 5000);

//   function x(y){
//     console.log("x");
//     y();
//   }

//   x(function y (){
//     console.log("y");
//   })
//    call back function is a function which is passed as an argument to another function and is executed after some time or some event occurs.

//  event listener
// document.getElementById("btn") .addEventListener("click", function  xyz (){
//     console.log("Button clicked");
// });
// let const

// console.log(a); 
// var a = 10;
// let b = 20;

//  if else 
// let age = "25";
// console.log(age);

// if (age == 25) console.log("(1),Age is 25");
// else console.log("(1),Age is not 25");


// if (age === 25) console.log("(2),Age is 25");
// else console.log("(2),Age is not 25");

// let age = Number(prompt("Enter your age: "));
// console.log(age);

// if (age == 50) {
//     console.log("you are an adult");
// }else  if( age ===15){
//     console.log("you are a teenager");
// } else {
//     console.log("age not defined"); 
// }

// type coercion
// In JavaScript, type coercion is the automatic or implicit conversion of values from one data type to another.
// This can happen in various situations, such as when using the == operator, which performs type coercion when comparing values.
// For example:
// let a = "5";
// let b = 5;

// console.log(a == b); // true, because a is coerced to a number
// console.log(a === b); // false, because a is a string and b is a number

// type conversion
// Type conversion in JavaScript is the process of converting a value from one data type to another.
// This can be done explicitly using built-in functions like Number(), String(), and Boolean().
// let a = "123";
// let b = Number(a); // explicit conversion from string to number
// console.log(b); // 123

// identifier
// In JavaScript, an identifier is a name used to identify a variable, function, or property.
// Identifiers must follow certain rules:
// 1. They can contain letters, digits, underscores (_), and dollar signs ($).
// 2. They must begin with a letter, underscore, or dollar sign.
// 3. They are case-sensitive (e.g., myVar and myvar are different identifiers).

// Examples of valid identifiers:
// let myVariable = 10;
// function myFunction() {

// function work() 

// var x = 1;
// a();
// b();
// console.log(x);

// function a() {
//     var x= 10;
//     console.log(x);
// }

// function b() {
//     var x= 100;
//     console.log(x);
// }

//  window/this

// var  a =10;
// function b () {
//     var x = 10;
// }
// console.log(window.a);

//  function statement
// function a() {
//     console.log("a called");
// }

// //  function expression
// var b = function(){
//     console.log("b called");
// }

// anonymous function
// function() {
//     console.log("Anonymous function called");
// }

// named function expression

// var b = function xyz(){
//      console.log("b called");
//  }
//  b();
//  xyz();

// parameters and arguments

// var b = function (para1, para2){ parameters
//      console.log("b called");
//  }
//  a();
//  b(1,2); arguments are the actual values passed to the function when it is called, while parameters are the variables defined in the function declaration that receive those values.

// first class functions
// var b = function (para1){
//    return function xyz() {

//    }
// }
// console.log(b());
// In JavaScript, functions are first-class citizens, which means they can be treated like any other variable. This includes being assigned to variables, passed as arguments to other functions, and returned from other functions.

// higher order functions:


//   x is callback function
// function x()  {      
//  console.log("x called");
// }

// //  y is higher order function
// function y (x){
//   x();
// }
//  again exp this ;


// const radius = [3,1,2,4,];

// const area = function (radius){
//    return Math.PI * radius * radius;
// }



// const circumference = function (radius){
//    return 2 * Math.PI * radius;
// }


// const diameter = function (radius){
//    return 2 *  radius;
// }

// const calculate = function (radius, logic){
//    const output = [];
//    for( let i = 1; i < radius.length; i++){
//       output.push(logic(radius[i]));
   
//    }
//    return output;
// }



// console.log(calculate(radius, area));
// console.log(calculate(radius, circumference));
// console.log(calculate(radius, diameter));

//  undefined vs not defined
// 1. Undefined means a variable has been declared but has not been assigned a value yet. It is a data type in JavaScript.

// var a;
// console.log(a); // Output: undefined

// 2. Not defined means a variable has not been declared at all in the current scope. Trying to access a not defined variable will result in a ReferenceError.

// console.log(b); // Output: ReferenceError: b is not defined

// var a;
// console.log(a);
// a = 10;
// console.log(a);
// a = "hello";
// console.log(a);

// dont mistake practise this 
// a = undefined;
// console.log(a);


//  generator function
//  is a special type of function that can be paused and resumed, allowing for more control over the execution flow and enabling the creation of iterators.

// function* generate(){
//    yield 1;
//    yield 2;
//     yield 3;

    
// }

// const generator  = generate();


// console.log(generator.next());
// console.log(generator.next());
// console.log(generator.next());

// pure function 
// function add(a,b){
//     return a + b;
// }

// console.log(add(2,5));
// console.log(add(2,5));

// currying function:


// function add(a){
//     return function(b) {
//         return a + b;
//     }
// }

// const addTwo = add(5);
// console.log(addTwo(4))

// IIFE:

// (function() {
//     var localVar = ' hello world' ;
//     console.log(localVar)
// })();

// var result = (function(){
//     var x = 10;
//     var y = 20;
//     return x + y;
// })();

// console.log(result);


// duplicate parameter names:
// function example(a,b,a){
//     console.log(a,b);
// }
// console.log(example(1,2,3));


// In JavaScript, when a function has multiple parameters with the same name, the last parameter with that name takes precedence. In the example above, the function example has three parameters: a, b, and a. When the function is called with the arguments (1, 2,3), the value of the first parameter a is overwritten by the value of the last parameter a. Therefore, when console.log(a, b) is executed, it outputs 2 for a and 2 for b.
  
// arrow function
// const greet = (name) => {
//     console.log(`Hello, ${name}!`)
// }

// greet('sara');

// learn function with comparing hoisting behaviour in js:
//  

// // object

// const person = {
//     firstName: "sara",
//     lastName: "john",
//     greet: function(){
//         console.log("Hello" + this.firstName);
//     }

    
// }
// person.greet();

//  object.freeze
// const user = {
//     username: "decode",
//     password:" 12345",
// };

// Object.freeze(user);
// user.username = "newUser";
// console.log(user);


// object.seal
// let orginalBox = {
//     shape: "cube",
//     color: "red",
   
// };

// let sealBox = Object.seal(orginalBox);
// sealBox.length = 5;
// sealBox.color = "green";
// sealBox.shape = "circle";
// delete sealBox.shape;
// console.log(sealBox);

// deep freeze
// is a process of recursively applying Object.freeze() to an object and all of its nested objects, making the entire object structure immutable and preventing any modifications to its properties at any level.

// const deepFreeze = (obj) => {
//     if (obj === null || typeof obj !== "object"){
//         return obj;
//     }

//     Object.keys(obj).forEach((key) => {
//         deepFreeze(obj[key]);
//     });
//       return Object.freeze(obj);
// }
        

// const obj1 = {
//     key1: "value1",
//     key2: {
//        nestedkey: "nestedvalue", 
//     },
//     key3: ["a", "b", "c"],
// }
// const deepFreezeObj = deepFreeze(obj1);

// console.log("Before Change:");
// console.log(deepFreezeObj);

// deep seal 
// is a process of recursively applying Object.seal() to an object and all of its nested objects, making the entire object structure non-extensible and preventing the addition or removal of properties at any level, while still allowing modifications to existing properties.

// function deepSeal(obj){
//     Object.seal(obj);
//     for (let key in obj){
//         if(
//             typeof obj[key] === "object" && obj[key] !== null && !Object.isSealed.isSealed(obj[key])
//         ){
//             deepSeal(obj[key]);
//         }
//         return obj;
//     }
// }

// const user = {
//     name: "sara",
//     address: {city: "kochi", country: "India"},
// };

// deepSeal(user);
// user.address.city = "banglore"; 
// user.age = 25;
// console.log(user);

// prortypal inheritance
// In JavaScript, prototypal inheritance is a way for objects to inherit properties and methods from other objects through their prototype chain.
// Every JavaScript object has a prototype, which is another object that it inherits properties and methods from.
// When you try to access a property or method on an object, JavaScript first looks for it on the object itself. If it doesn't find it there, it looks for it on the object's prototype, and so on up the prototype chain until it finds the property or method or reaches the end of the chain.

// prototype
//  is a mechanism by which objects in JavaScript can inherit properties and methods from other objects.

// const parent = {
//     greet: function() {
//         console.log("Hellooo....");
//     }
// };

// const child = Object.create(parent);

// child.sayHi = function(){
//     console.log("Hi.... child here");
// }

// child.greet();
// child.sayHi();

// prototype chain :

// 
//   function Animal(name) {
//   	this.name = name;
// }

// Animal.prototype.speak = function () {
//   	console.log(`${this.name} makes a sound.`);
// };

// const dog = new Animal("Buddy");

// console.log(dog.name);
// dog.speak();

// __proto__
// In JavaScript, __proto__ is a property of an object that points to the prototype of that object. It is used to access the prototype chain and inherit properties and methods from the prototype object.

// let animal = {
//     animalEats: true,

// };

// let rabbit = {
//     rabbitJumps: true,
// };

// rabbit.__proto__ = animal;
// console.log(rabbit.animalEats);
// console.log(rabbit.rabbitJumps);

// object.keys
// const user = { name: "Huda", age:22, city: "kochi"};
// console.log(Object.keys(user));

// // object.values
// console.log(Object.values(user));

// // object.entries
// console.log(Object.entries(user));

// for(const [key,value] of Object.entries(user)){
//     console.log(`${key}: ${value}`);
// }

// object.fromEntries
// const arr = [["name", "Huda"], ["age", 22]];
// console.log(Object.fromEntries(arr));

// // object.assign
// const obj1 = {a:1};
// const obj2 = {b:2};

// const combined = Object.assign({}, obj1, obj2);
// console.log(combined);

//  spread 
// const clone = {... user};
// const merged = {...obj1, ...obj2};
// console.log(merged);

// DOM

// let Tag = document.getElementsByTagName("h1");
// let button = document.getElementById("btn");
// let para = document.getElementsByClassName("para");

// queryselector 

// let head = document.querySelector('h1');
// let button = document.querySelector('#btn');
// let para = document.querySelectorAll(".para");

// head.style.color = "green";
// head.style.background = "yellow";
// head.style.fontSize = "100px";

// para[0].innerHTML = "Hello John!"

// collection, nodelist difference:

// let para = document.getElementById("para");
// let list = document.getElementsByClassName("list");

// console.log(para);
// console.log(list);


// node list create elements:

// const collection = document.querySelector("#list");
// // const list = document.querySelectorAll(".item");
// const  para = document.querySelector("#para");

// const list = collection.children;

// // new :
// const NewItem = document.createElement("li");



//  NewItem.classList.add('item');

// NewItem.innerText = "item2";

// collection.appendChild(NewItem);

// para.innerText =  list.length;


// creating elements, html collections:
// item 3
// const collection1 = document.getElementById("list");
// const list1 = document.getElementById("item");
// const para = document.getElementById("para");

// const item1 = document.createElement("li");
// item1.classList.add('item1');
// item1.innerText = "item2";
// collection1.appendChild(item1);


// const item2 = document.createElement("li");
// item2.classList.add('item2');
// item2.innerText = "item3";
// collection1.appendChild(item2);


// const item3 = document.createElement("li");
// item3.classList.add('item2');
// item3.innerText = "item4";
// collection1.appendChild(item3);
// end:

// events 

// const button = document.querySelector("#submit")
// const head = document.querySelector("#head");

// button.addEventListener("click", function(){
//     head.innerText = "Hello Event";

// });

// create list 
// const button = document.querySelector("#submit")
// const list = document.querySelector("#list");
// const items = list.children;

// button.addEventListener("click", function(){

// const NewItem = document.createElement("li")
// NewItem.classList.add("items");
// NewItem.innerText = "items";
// list.appendChild(NewItem);
// });

// e.
// const head = document.querySelector("#head");

// head.addEventListener('click', function(e){
//    e.target.innerHTML = "Hello john"
// })

// const input = document.querySelector("#input-text");

// input.addEventListener('keyup' , myFun)

// function myFun(e){
//     console.log(e.code);
// }

//  event bubbling 

// const Mother = document.querySelector("#mother");
// const Child = document.querySelector("#child");

// Child.addEventListener("click", function(e){
//     console.log("Clicked child");
//     // propagation
//     e.stopPropagation();
// });

// Mother.addEventListener("click", function(){
//    console.log("Clicked Mother")
  
   
// });

// local storage:
// localStorage.setItem("name", "john");
// const Names = localStorage.getItem('name')
// console.log(typeof Names);

// session storage

// sessionStorage.setItem('name', "Jerry");

// const Names = ['james', 'davis', 'sara']

// localStorage.setItem('names', JSON.stringify(Names))

// const Ary = JSON.parse(localStorage.getItem("names"))
// console.log(Ary);
// event bubbling and stoppropagation
// let grandParent = document.getElementById("grandparent");
// let parent = document.getElementById("parent");
// let child = document.getElementById("child");

// grandParent.addEventListener("click", (e) =>{
//   console.log('grandparent bubbling')
// });

// parent.addEventListener("click", (e) =>{
//    e.stopPropagation();
// });

// child.addEventListener("click", (e) =>{
//    console.log("child bubbling")
// }, true);


// event delegation
// const customUI = document.createElement('ul');
// function responding(evt){
//     if (evt.target.nodeName === 'LI')
//         console.log('Responding')
// }
// for (let i = 1; i <= 10; i++){
//     const newElement = document.createElement('li');
//     newElement.textContent = "This is line " + i;
   
//     customUI.appendChild(newElement);
// }
// customUI.addEventListener('click', responding);
// document.body.appendChild(customUI);

//  how to DOM works :
// How the DOM Works?
// The DOM connects your webpage to JavaScript, allowing you to:

// Access elements (like finding an <h1> tag).
// Modify content (like changing the text of a <p> tag).
// React to events (like a button click).
// Create or remove elements dynamically.


// // shallow copy
// let employee = {
//     eid : "2h3",
//     ename : "Jack",
//     esalary : "50000"
// }

// console.log("Employee=>", employee);

// // sahllow copy 
// let newEmployee = {... employee};
// console.log("New Employee=>", employee);

// console.log("--------After modification --------");
// newEmployee.ename = "Beck";

// console.log("Employee=>", employee);
// console.log("New Employee=>", newEmployee);
 
// deep copy
// let employee = {
//     eid: "E102",
//     ename: "jack",
//     eaddress: "New York",
//     salary: 50000
// }

// console.log("====deep copy===");
// let newEmployee = JSON.parse(JSON.stringify (employee));

// console.log("Employee=>", employee);

// console.log("New Employee=>", newEmployee);

// console.log("---------After modification----");
// newEmployee.ename = "Beck";
// newEmployee.salary = 70000;
// console.log("Employeee=>",employee);
// console.log("New Employee=>", newEmployee);

// Lodash to deep copy

// const lodash = require('lodash');



// let employee = {
//     eid: "E102",
//     ename: "jack",
//     eaddress: "New York",
//     salary: 50000,
//     details : function(){
//         return "Employee name:"+ this.ename + "-->Salary:" + this.salary;
//     }
// }

// let deepCopy = lodash.cloneDeep(employee);
// console.log("Original employee object");
// console.log(employee);


// console.log("Deep copied employee object");
// console.log(deepCopy);

// deepCopy.eid = "E104";
// deepCopy.ename = "Beck";
// deepCopy.details = function(){
//      return "Employee ID:"+ this.eid + "-->Salary:" + this.salary;
//     }

// console.log("----After modification-----");


// console.log("original employee object");
// console.log(employee);


// console.log("Deep copied object");
// console.log(deepCopy);


// console.log(employee.details());
// console.log(deepCopy.details())
// oop
// let Names = {
//     Name: "john",
//     Age :24,
//     Sayname (){
//         console.log(this.Age)
//     }

// };
// Names.Sayname();

// this keyword


// // bind
// const Name = {
//     firstname: "john",
// }

// function binder(){
//     console.log(this)
// }
// binder.apply(Name,["john"]);

// abstraction 

// class P {
//     constructor(name,age){
//         this.name= name;
//         this.age= age;
//     }
//     getD() {
//        return   `${this.name} is ${this.age} yaers old.`;
//     }
// }

// const p1 = new P("Anju", 30);
// console.log(p1.getD());

// function  constructor:

// function Car(make, model, year){
//     this.make= make;
//     this.model = model;
//     this.year = year;

//     this.getCarInfo = function(){
//         return `${this.year} ${this.make} ${this.model}`;
//     };
// }

// let myCar = new Car('Toyota', 'CaMry', 2020);
// console.log(myCar.getCarInfo())
// ;

// class constructor:

// class Car {
//     constructor(make,model,year){
//         this.make = make;
//         this.model = model;
//          this.year = year;

//     }

//     getCarInfo(){
//         return `${this.year} ${this.make} ${this.model}`
//     }
// }

// let myCar =  new Car ('Honda', 'Civic', 2022);
// console.log(myCar.getCarInfo());


// new keyword:
// function prints(name,age)
// {
//     this.name=name;
//     this.age= age;
// }

// const result = new prints('Pranjal', 21)

// console.log(result);

// class Person {
//     constructor(name,age){
//         this.name = name;
//         this.age  = age;
//     }
// }

// const result1 = new Person('john', 30);
// console.log(result1);

//  object.craete():

// const obj = {
//     name: 'john',
//     age: 21
// }

// const obj1 = Object.create(obj)
// obj1.class = '10th'
// console.log(obj1.name);

// object factory function:

// function createPerson(name,age){
//     return {
//         name: name,
//         age: age,
//         greet: function(){
//             console.log(`Hello my name is ${this.name}`);
//         }
//     };
// }

// const person1 = createPerson('john', 24);
// const person2= createPerson('sara', 24);

// person1.greet();
// person2.greet();

// constructor with default values:

// function Person (name = "Unknown", age = 0){
//     this.name = name;
//     this.age = age;
// }

// const person1 = new Person("john", 30);
// const person2 = new Person("sara", 30);
// const person3 = new Person();


// console.log(person1);
// console.log(person2);
// console.log(person3);

//  Constructor with method on prototypes:

// function Person(name, age){
//     this.name = name;
//     this.age = age;

// }

// Person.prototype.greet = function(){
//     console.log(`Hello my name is ${this.name} and i am ${this.age} years old`);
// };

// const person1= new Person("john", 25);
// const person2= new Person("sara", 25);

// person1.greet();
// person2.greet();

// constructor with inheritance:

// class one {
//     constructor(name)
//     {
//         this.name = name;
//     }
//     greet()
//     {
//         return `Hello  ${this.name}`
//     }
// }
// class two extends one {
//     constructor(name,age)
//     {
//         super(name)
//         this.age = age
//     }
//     greet1(){
//         return `your age is ${this.age}`
//     }
// }

// const person1 = new one ('john',24);
// const person2 = new two ('elin',24);

// console.log(person2.greet());


// this keyword:
// const person = {
//     name: "john",
//     greet(){
//           return `Welcome to, ${this.name};`
//     }
// }
// console.log(person.greet());

//  this keyword in methods:

// const person = {
//     name: 'john',
//     age:30,
//     greet(){
//         console.log(`Hello my name is  ${this.name} and i aM ${this.age} years old`)
//     }

// };
// person.greet();

//  this in function:

// function greet(){
//     console.log('Hello my name is ' + this.name);
// }

// const person = {
//     name:'Huda',
//     sayHello: greet

// };

// const anotherPerson = {
//     name:'John'
// }

// greet();
// person.sayHello();
// greet.call(anotherPerson);

// Using this alone(Global Context):
// console.log(this);

//  Implicit Binding:
// const person= {
//     name: 'john',
//     age:22,
//     greet: function(){
//         return `Hello ${this.name} ,you are ${this.age} years old`
//     }
// }

// console.log(person.greet());

// Explicit Binding:
// function ageVerify(){
//     if(this.age > 18){
//         console.log("Yes you can drive")
//     }else{
//         console.log("No you cannot drive");
//     }
// }

// const per1 = {age:21};
// const per2 = {age:15};

// ageVerify.call(per1);
// ageVerify.call(per2);

//  Default Binding:
// const age = 22;
// function verifyAge (){
//     return this.age;
// }
// console.log(verifyAge());

//  Arrow Function Binding:

// const person = {
//     name: "john",
//     age: 22,
//     greet: ()=> {
//         return ` Hello , you are ${this.age} years old`
//     }
// }

// console.log(person.greet());

//  bind():
// const car = {
//     brand: 'Lamborgini',

// }

// const printDetail = function(model, toSpeed){
//     console.log(`${this.brand} ${model} has a topspeed of ${toSpeed} mph`);
// }

// printDetail('Nissan',234);


// const lamboPrintDetail = printDetail.bind(car);
// lamboPrintDetail('Diablo VTTT', 222);


// const reventonPrintDetail = printDetail.bind(car, 'Reventon', 221);

// reventonPrintDetail(); 

// call():
// const obj = {
//     firstName: "First_name",
//     lastName: "Last_name",
//     printName: function(){
//         console.log(this.firstName
//             + " " + 
//             this.lastName
//         );
//     }

// };
// obj.printName();

// const obj1 = {
//     firstName: "First_name",
//      lastName: "Last_name",
// };
// const obj2 = {
//     firstName:"John",
//     lastName: "Doe"
// };
// function printName(proffession, country){
//  console.log(this.firstName + " " + this.lastName+" " + proffession + " " + country);
// }
// printName.call(obj2, "writer", "London");

// apply();

// const obj1 = {
//      firstName: "First_name",
//       lastName: "Last_name",
// };
//  const obj2 = {
//       firstName:"John",
//       lastName: "Doe"
// };
// function printName(proffession, country){
//     console.log(this.firstName + " " + this.lastName+ " " + proffession+ " " + country);
// }
// printName.apply(obj2, ["Writer", "London"]);

// object methods:

// let student = {
//     name:"John",
//     class:"12th",
//     section:"A",

//     studentDetails: function(){
//         return this.name+ " "+this.class+" "+ this.section+" ";
//     }
// };
// console.log("STUDENT"+student.studentDetails())

// scope:
// global
// const x = 10;

// function fun1(){
//   console.log(x);
// }

// fun1();

// function scope:

// function fun2(){
//     let x = 10;
//     console.log(x);
// }

// fun2();

// block scope:

// {
//     var x = 10;

//     const y = 20;

//     let z=30;

//     console.log(x);
//      console.log(y);
//       console.log(z);
// }
//  console.log(x);

//  lexical scope:
// function fun1(){
//     const x = 10;

// function fun2(){
// const y =20;
// console.log(`${x} ${y}`)
//     }
//     fun2()
// }

// fun1();

// call():
// const student = {
//     name: "john",
//     printName: function(){
//         console.log(this.name);
//     },
// }
// student.printName();

// const student1 = {
//     name: "sara",
  
// }
// student.printName.call(student1);


// nested  arrow function this:
// const obj = {
//    a:10,
//    x: () => {
//     console.log(this);
//    } 
// };
// obj.x();

// const obj2 ={
//     a:20,
//     x: function() {
//         // enclosing lexical context:
//         const y = () =>{
//             console.log(this)
//         }
//         y();
//     },

// };
// obj2.x();


// asynchronous js: and event loop
// console.log("hi");

// setTimeout(() =>{
//     console.log("helo john");
// }, 5000);

// console.log("end");


// console.log("start");

// document.getElementById("btn");
// btn.addEventListener("click", function cb(){
//  console.log("callback");
// });

// console.log("end");

// fetch();
// console.log("start");

// setTimeout(function cbT(){
//     console.log("CB SetTimeout");
// }, 5000);

// // microtask
// fetch("https://api.netflix.com")
// .then(function cbF() {
//     console.log("CB netflix");
// });

// console.log("end");

//  destructuring:
// array destructuring:
// const a = [10,20,30,40];

// console.log("Ex1");
// const [x,y,z] = a;
// console.log(x);
// console.log(y);
// console.log(z);

// const[p,q, , r] = a;
// console.log("ex2");
// console.log(p);
// console.log(q);
// console.log(r);

// const[s,t] = a;
// console.log("ex3");
// console.log(s);
// console.log(t);

// rest operator:

// let [fst, , ...last] = ["a", "b", "c", "d"];

// console.log(fst);
// console.log(last);

// swapping:

// let nx = 10, ny = 20;
// [nx,ny] = [ny,nx];

// console.log(nx);
// console.log(ny);

// functtion return:
// function name(){
//     return["a", "b", "c"];
// }

// let [fst, snd] = name();
// console.log(fst);
// console.log(snd);

// object destructuring:
// ({x,y} = {x:10, y:20});
// console.log(x);
// console.log(y);

// ({x,y, ...restof} = {x:10, y:20, m:30, n:40});
// console.log(x);
// console.log(y);
// console.log(restof);


// nested object destructuring:

// const marks = {
//     section1:{alpha:15, beta:16},
//      section1:{alpha:-31, beta:19},
// };

// const {section1: {alpha:alpha1, beta:beta1}} = marks;
// console.log(alpha1,beta1);

// deep clone 

// let student1 = {
//     name: "john",
//     company: "gfg"
// }

// let student2 = {...student1};

// student1.name = "sara";

// console.log(" stuent 1 name is:", student1.name);
// console.log(" stuent 2 name is:", student2.name);

// object.assign():

// let student1 = {
//     name: "john",
//      company: "gfg"
// }

// let student2 = Object.assign({}, student1);

// student1.name = "sara";

// console.log("student 1 name is:", student1.name);
// console.log("student 2 name is:", student2.name);

// json parse and stringify methods:

// let student1 = {
//     name: "john",
//      company: "gfg"
// }

// let student2 = JSON.parse(JSON.stringify(student1));

// student1.name = "Doe";

// console.log("student 1 name is:", student1.name);
// console.log("student 2 name is:", student2.name);


//  map():
// const arr = [5,1,3,2,6];

// const output = arr.map((x) => x * 2);
// console.log(output);

// filter():

// const arr = [5,1,3,2,6];

// function isOdd(x){
//     return x% 2;
// }

// const output = arr.filter(isOdd);
// console.log(output);

// greated than:
// const arr = [5,1,3,2,6];


// const output = arr.filter((x) => x > 4);
// console.log(output);



// let arr = [2,4,8,10];
// let updateArr = arr.slice().filter(val => val < 5);
// console.log(arr);
// console.log(updateArr);

// reduce();

//  let arr = [2,4,8,10];
//  let updateArr = arr.reduce((prev,  curr)=> curr=  prev+curr)
// console.log(arr);
// console.log(updateArr);

// const arr = [5,1,3,2,6];

// function findSum (arr){
//   let sum = 0;
//   for (let i = 0; i , arr.length; i++){
//     sum= sum + arr[i];
//   }
//   return sum;
// }

// console.log(findSum(arr));

// const output = arr.reduce ( function(acc,  curr) {
//     acc = acc + curr
//    return acc
// }, 0);

// console.log(output);
    
// const arr = [5,1,3,2,6];

// function findMax (arr){
//   let max = 0;
//   for (let i = 0; i < arr.length; i++){
//    if (arr[i] > max){
//     max = arr[i];
//    }
//   }
//   return max;
// }

// // console.log(findSum(arr));

// const output = arr.reduce(function(max,  curr){
//   if (curr > max){
//     max = curr;
//   }
//   return max;
// })
// console.log(output);

// object reduce():

// const users = [
//   { firstName: "john", lastName: "doe", age: 22},
//   { firstName: "sara", lastName: "smith", age: 25},
//   { firstName: "peter", lastName: "jones", age: 20},
// ];

// const output = users.map((x) => x.firstName + " " + x.lastName);
// console.log(output);

const fruits = ["apple", "banana", "orange", "mango"];

let fruit = fruits.toUpperCase();
console.log(fruit);